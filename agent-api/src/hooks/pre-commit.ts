/**
 * Pre-commit Hook Installation
 *
 * Generates a .git/hooks/pre-commit script that delegates to all
 * .discobot/hooks/ files with type: pre-commit.
 *
 * If an existing pre-commit hook exists (not created by discobot),
 * it is preserved as .git/hooks/pre-commit.original and chained.
 *
 * The generated script captures each hook's output and updates
 * ~/.discobot/{sessionId}/hooks/status.json for status tracking.
 */

import { chmod, readFile, rename, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { Hook } from "./parser.js";

/** Marker comment to identify discobot-managed pre-commit hooks */
const MANAGED_MARKER = "# discobot:managed";

/**
 * Install a git pre-commit hook that runs all discobot pre-commit hooks.
 *
 * - Preserves existing non-discobot hooks as .git/hooks/pre-commit.original
 * - Generates a script that chains the original hook (if any) and discobot hooks
 * - Marks the file with a managed marker so we can identify it later
 * - Each hook's result is persisted to status.json for API access
 */
export async function installPreCommitHook(
	workspaceRoot: string,
	preCommitHooks: Hook[],
	sessionId: string,
): Promise<void> {
	if (preCommitHooks.length === 0) return;

	const gitHooksDir = join(workspaceRoot, ".git", "hooks");
	const hookPath = join(gitHooksDir, "pre-commit");
	const originalPath = join(gitHooksDir, "pre-commit.original");

	// Check if an existing pre-commit hook needs to be preserved
	try {
		const existing = await readFile(hookPath, "utf-8");
		if (!existing.includes(MANAGED_MARKER)) {
			// Existing hook not managed by us — preserve it
			console.log(
				"[hooks] Preserving existing pre-commit hook as pre-commit.original",
			);
			await rename(hookPath, originalPath);
		}
	} catch {
		// No existing hook — nothing to preserve
	}

	// Generate the pre-commit script
	const script = generatePreCommitScript(preCommitHooks, sessionId);

	await writeFile(hookPath, script, "utf-8");
	await chmod(hookPath, 0o755);

	console.log(
		`[hooks] Installed git pre-commit hook (${preCommitHooks.length} hook(s): ${preCommitHooks.map((h) => h.name).join(", ")})`,
	);
}

/**
 * Generate the pre-commit shell script content.
 *
 * Each hook is wrapped with output capture and status reporting.
 * Status is updated via an inline node/bun script that reads/writes status.json.
 */
function generatePreCommitScript(hooks: Hook[], sessionId: string): string {
	const lines: string[] = [];

	lines.push("#!/bin/bash");
	lines.push("# Auto-generated by discobot hooks system");
	lines.push("# Source: .discobot/hooks/");
	lines.push("# DO NOT EDIT — regenerated when hooks change");
	lines.push(MANAGED_MARKER);
	lines.push("");

	// Chain original hook if preserved
	lines.push("# Run preserved original pre-commit hook");
	lines.push('if [ -f "$(dirname "$0")/pre-commit.original" ]; then');
	lines.push('  "$(dirname "$0")/pre-commit.original" || exit $?');
	lines.push("fi");
	lines.push("");

	// Setup hooks data dir for status tracking
	lines.push("# Status tracking setup");
	lines.push(`HOOKS_DATA_DIR="\${HOME}/.discobot/${sessionId}/hooks"`);
	lines.push('mkdir -p "$HOOKS_DATA_DIR/output"');
	lines.push("");

	// Status update function using node or bun
	lines.push("# Update hook status in status.json");
	lines.push("update_hook_status() {");
	lines.push('  local hook_id="$1"');
	lines.push('  local hook_name="$2"');
	lines.push('  local success="$3"');
	lines.push('  local exit_code="$4"');
	lines.push('  local output_path="$5"');
	lines.push("");
	lines.push("  local js_cmd");
	lines.push("  if command -v node >/dev/null 2>&1; then");
	lines.push("    js_cmd=node");
	lines.push("  elif command -v bun >/dev/null 2>&1; then");
	lines.push("    js_cmd=bun");
	lines.push("  else");
	lines.push("    return 0");
	lines.push("  fi");
	lines.push("");
	lines.push(
		'  HOOK_ID="$hook_id" HOOK_NAME="$hook_name" HOOK_SUCCESS="$success" \\',
	);
	lines.push(
		'  HOOK_EXIT_CODE="$exit_code" HOOK_OUTPUT_PATH="$output_path" \\',
	);
	lines.push('  STATUS_DIR="$HOOKS_DATA_DIR" \\');
	lines.push('  "$js_cmd" -e \'');
	lines.push('    const fs = require("fs");');
	lines.push('    const path = require("path");');
	lines.push(
		"    const { HOOK_ID, HOOK_NAME, HOOK_SUCCESS, HOOK_EXIT_CODE, HOOK_OUTPUT_PATH, STATUS_DIR } = process.env;",
	);
	lines.push('    const statusPath = path.join(STATUS_DIR, "status.json");');
	lines.push('    let status = { hooks: {}, lastEvaluatedAt: "" };');
	lines.push(
		'    try { status = JSON.parse(fs.readFileSync(statusPath, "utf-8")); } catch {}',
	);
	lines.push("    if (!status.hooks) status.hooks = {};");
	lines.push("    const existing = status.hooks[HOOK_ID] || {};");
	lines.push('    const success = HOOK_SUCCESS === "true";');
	lines.push("    const exitCode = parseInt(HOOK_EXIT_CODE, 10);");
	lines.push("    status.hooks[HOOK_ID] = {");
	lines.push("      hookId: HOOK_ID,");
	lines.push("      hookName: HOOK_NAME,");
	lines.push('      type: "pre-commit",');
	lines.push("      lastRunAt: new Date().toISOString(),");
	lines.push('      lastResult: success ? "success" : "failure",');
	lines.push("      lastExitCode: exitCode,");
	lines.push("      outputPath: HOOK_OUTPUT_PATH,");
	lines.push("      runCount: (existing.runCount || 0) + 1,");
	lines.push("      failCount: (existing.failCount || 0) + (success ? 0 : 1),");
	lines.push(
		"      consecutiveFailures: success ? 0 : (existing.consecutiveFailures || 0) + 1,",
	);
	lines.push("    };");
	lines.push('    const tmpPath = statusPath + ".tmp." + Date.now();');
	lines.push(
		"    fs.mkdirSync(path.dirname(statusPath), { recursive: true });",
	);
	lines.push(
		'    fs.writeFileSync(tmpPath, JSON.stringify(status, null, "\\t"));',
	);
	lines.push("    fs.renameSync(tmpPath, statusPath);");
	lines.push("  ' 2>/dev/null || true");
	lines.push("}");
	lines.push("");

	// Hook runner function
	lines.push("# Run a single hook with output capture and status tracking");
	lines.push("run_hook() {");
	lines.push('  local hook_path="$1"');
	lines.push('  local hook_id="$2"');
	lines.push('  local hook_name="$3"');
	// biome-ignore lint/suspicious/noTemplateCurlyInString: bash variable interpolation, not JS template
	lines.push('  local output_path="$HOOKS_DATA_DIR/output/${hook_id}.log"');
	lines.push("");
	lines.push("  local output exit_code");
	lines.push('  output=$("$hook_path" 2>&1) && exit_code=0 || exit_code=$?');
	lines.push("");
	lines.push('  printf \'%s\\n\' "$output" > "$output_path"');
	lines.push("");
	lines.push("  if [ $exit_code -ne 0 ]; then");
	lines.push("    printf '%s\\n' \"$output\" >&2");
	lines.push(
		'    update_hook_status "$hook_id" "$hook_name" "false" "$exit_code" "$output_path"',
	);
	lines.push("    exit $exit_code");
	lines.push("  fi");
	lines.push("");
	lines.push(
		'  update_hook_status "$hook_id" "$hook_name" "true" "0" "$output_path"',
	);
	lines.push("}");
	lines.push("");

	// Run each discobot hook
	lines.push("# Run discobot pre-commit hooks");
	for (const hook of hooks) {
		lines.push(`run_hook "${hook.path}" "${hook.id}" "${hook.name}"`);
	}
	lines.push("");

	return lines.join("\n");
}
